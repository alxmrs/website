
Today, I attended my alma mater's National Cognitive Science Conference on the alumni panel. 
I got a chance to impart advice to undergraduates in attendance. Below is a summary,
as best as I can remember, if what I said at my table. I hope that these words prove valuable
for the current undergraduate who attended the conference -- or for those that
are looking for thoughts on technology. 


## Q: What does working as a software engineer look like? 

TL;DR: The [Agile process](https://en.wikipedia.org/wiki/Agile_software_development#Overview), typically. A [Waterfall](https://en.wikipedia.org/wiki/Waterfall_model#Model) process if you're unlucky.


## Q: Can you tell me about the research job posting for undergraduates?

Posting: [https://bit.ly/mlresearch2019](https://bit.ly/mlresearch2019)

TL;DR: Write ML tools for NanoEngineers to speed up the discovery and development of materials. So far, this has involved working with [EBSD](https://en.wikipedia.org/wiki/Electron_backscatter_diffraction) data 
using Python 3 and convolution neural networks. 

The current problem that we are dealing with is estimating [lattice parameters](https://en.wikipedia.org/wiki/Lattice_constant) from EBSD images. 
These parameters can be used to represent the 3D crystal structure of particles. 

## What are the requirements for the job? What if we  don't have N years experience in python? What do you look for in candidates?

Less important to me than knowing a particular skill (or having a laundry list of buzzwords on your resume) is demonstration 
of the ability to learn things quickly. 

After a certain point, software engineering involves minimal knowing of things. Sure, there are fundamentals that 
usually are internalized. However, even the most veteran software engineers look up basic stuff on a daily basis. [TODO: link to tweet about this](#TODO)

The real skill involved in this type of engineering comes from knowing what to search for. 

Really, you have to know enough of the basics to know what kinds of things are out there to search for -- and there 
definitely are common conventions that appear across languages, frameworks, and tools. Still, the ability to expand one's 
personal sphere of knowledge, even to naive but adequate degree, is the critical ability that developers stake their livelihood. 

Prior experience in a project is a really good indicator of this meta-skill. It's even OK if the project doesn't include
the specific nuances that are used in the position are applying for. It's typical that every shop in industry to follow their own conventions
and opinions. 

That said, it's clear from a project when decisions were made not due to a differing opinion, but rather a lack of opinion.

(See [this](#TODO) section below for a list of resources I recommend to get an understanding of what kind of opinions are out there.)


## Why do you list Java and C++ when the position uses Python? 



Understanding programming languages is no too different than understanding human languages. 

In human languages -- let's say, at least in English -- the verb is the most expressive part of a sentence. 
To *go* can mean the same things as to *run* or to *saunter*, but *run* and *saunter* mean very different things.
Sentences can express denser meaning by using a more sophisticated verb.



## What other areas of pure math are useful for industry?


## Recommended Readings

[Software Engineering](https://docs.google.com/document/d/1blhv7cizcC85vP88VuI9SgE4wlq-d7SsnsQcq2c2lnU/edit?usp=sharing)


[Machine Learning](https://docs.google.com/document/d/11VAATynYgdbD3eOPSiIDV1DKOz_bt2gypTcl097fBJU/edit?usp=sharing)
